<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2D Traffic Racer</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #0f0f0f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  canvas {
    display: block;
    background: #1e1e1e;
    margin: 0 auto;
  }
  #overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.85);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 24px;
    user-select: none;
    z-index: 9999;
    text-align: center;
    padding: 20px;
  }
  #overlay h1 {
    font-size: 48px;
    margin-bottom: 20px;
  }
  #overlay button {
    margin-top: 20px;
    padding: 14px 28px;
    font-size: 20px;
    border: none;
    border-radius: 8px;
    background: linear-gradient(135deg, #00cc66, #00994d);
    color: white;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    transition: background 0.3s, transform 0.2s;
  }
  #overlay button:hover {
    background: linear-gradient(135deg, #00a653, #007f3a);
    transform: translateY(-2px);
  }
</style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="overlay">
    <h1>Game Over</h1>
    <p id="scoreDisplay"></p>
    <button id="restartBtn">Restart</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const overlay = document.getElementById('overlay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const restartBtn = document.getElementById('restartBtn');

    let W, H;

    function resize() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    const laneWidth = 80;
    let laneOffset = 0;

    const player = {
      width: 50,
      height: 100,
      x: 0,
      y: 0,
      speedX: 0,
      maxSpeedX: 10
    };

    const keys = {};

    let enemies = [];
    let gameOverFlag = false;
    let score = 0;

    function randomPastelColor() {
      const r = Math.floor(Math.random() * 127 + 128);
      const g = Math.floor(Math.random() * 127 + 128);
      const b = Math.floor(Math.random() * 127 + 128);
      return `rgb(${r},${g},${b})`;
    }

    function canSpawnAt(x, y, width, height) {
      const minDistanceY = 200;
      for (let enemy of enemies) {
        let dx = Math.abs(enemy.x - x);
        let dy = Math.abs(enemy.y - y);
        if (dx < width && dy < minDistanceY) {
          return false;
        }
      }
      return true;
    }

    function spawnEnemy() {
      if (enemies.length >= 4) return;

      const types = ['car', 'car', 'car', 'truck'];
      const type = types[Math.floor(Math.random() * types.length)];

      let width = type === 'truck' ? 70 : 50;
      let height = type === 'truck' ? 160 : 100;

      const emptyLane = Math.floor(Math.random() * 5);

      let tries = 0;
      while (tries < 15) {
        let laneIndex = Math.floor(Math.random() * 5);

        if (laneIndex === emptyLane) {
          tries++;
          continue;
        }

        const roadMargin = (W - laneWidth * 5) / 2;
        let x = roadMargin + laneIndex * laneWidth + laneWidth / 2 - width / 2;
        x += (Math.random() * 20) - 10;

        let y = -height - Math.random() * 300;

        if (canSpawnAt(x, y, width, height)) {
          enemies.push({ x, y, width, height, color: randomPastelColor(), type });
          break;
        }
        tries++;
      }
    }

    function drawRoad() {
      ctx.fillStyle = '#222';
      ctx.fillRect(0, 0, W, H);

      const roadMargin = (W - laneWidth * 5) / 2;

      ctx.fillStyle = '#666';
      ctx.fillRect(0, 0, roadMargin, H);
      ctx.fillRect(W - roadMargin, 0, roadMargin, H);

      ctx.strokeStyle = 'white';
      ctx.lineWidth = 4;
      ctx.setLineDash([30, 30]);

      for (let i = 1; i < 5; i++) {
        let x = roadMargin + i * laneWidth;
        ctx.beginPath();
        for (let y = -30 + laneOffset; y < H; y += 60) {
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + 30);
        }
        ctx.stroke();
      }

      ctx.setLineDash([]);
    }

    function drawVehicle(x, y, width, height, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, width, height);
    }

    function drawPlayer() {
      drawVehicle(player.x, player.y, player.width, player.height, '#00aaff');
    }

    function drawEnemies() {
      for (let enemy of enemies) {
        drawVehicle(enemy.x, enemy.y, enemy.width, enemy.height, enemy.color);
      }
    }

    // Simple AABB collision detection
    function isColliding(a, b) {
      return !(a.x > b.x + b.width ||
               a.x + a.width < b.x ||
               a.y > b.y + b.height ||
               a.y + a.height < b.y);
    }

    function endGame() {
      gameOverFlag = true;
      overlay.style.display = 'flex';
      scoreDisplay.textContent = `Score: ${score}`;
    }

    function update() {
      if (gameOverFlag) return;

      laneOffset += 10;
      if (laneOffset >= 60) laneOffset = 0;

      // Player input handling
      if (keys['arrowleft'] || keys['a']) {
        player.speedX -= 1;
      }
      if (keys['arrowright'] || keys['d']) {
        player.speedX += 1;
      }
      if (!keys['arrowleft'] && !keys['a'] && !keys['arrowright'] && !keys['d']) {
        player.speedX *= 0.8;
      }

      if (player.speedX > player.maxSpeedX) player.speedX = player.maxSpeedX;
      if (player.speedX < -player.maxSpeedX) player.speedX = -player.maxSpeedX;

      player.x += player.speedX;

      const roadMargin = (W - laneWidth * 5) / 2;
      if (player.x < roadMargin) player.x = roadMargin;
      if (player.x + player.width > W - roadMargin) player.x = W - roadMargin - player.width;

      // Spawn enemies occasionally
      if (Math.random() < 0.02) spawnEnemy();

      // Move enemies down and remove if offscreen
      const enemySpeed = 5;
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemySpeed;
        if (enemies[i].y > H) {
          enemies.splice(i, 1);
        }
      }

      // Check collision with player
      for (let enemy of enemies) {
        if (isColliding(player, enemy)) {
          endGame();
          break;
        }
      }

      score++;
      
      ctx.fillStyle = '#1e1e1e';
      ctx.fillRect(0, 0, W, H);

      drawRoad();
      drawPlayer();
      drawEnemies();

      requestAnimationFrame(update);
    }

    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
    });

    window.addEventListener('keyup', e => {
      keys[e.key.toLowerCase()] = false;
    });

    restartBtn.addEventListener('click', () => {
      if (!gameOverFlag) return;
      overlay.style.display = 'none';
      enemies = [];
      score = 0;
      gameOverFlag = false;
      const roadMargin = (W - laneWidth * 5) / 2;
      player.x = roadMargin + laneWidth * 2 + laneWidth / 2 - player.width / 2;
      player.y = H - player.height - 50;
      player.speedX = 0;
      update();
    });

    function init() {
      const roadMargin = (W - laneWidth * 5) / 2;
      player.x = roadMargin + laneWidth * 2 + laneWidth / 2 - player.width / 2;
      player.y = H - player.height - 50;
      player.speedX = 0;

      update();
    }

    init();
  </script>
</body>
</html>
